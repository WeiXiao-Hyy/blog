## 引言

本文深入理解Java泛型，内容主要参考于《On Java》和《Effective Java》。

PS: [https://github.com/WeiXiao-Hyy/blog](https://github.com/WeiXiao-Hyy/blog)整理了后端开发的知识网络，欢迎Star！

## 协变,逆变,不变性

### 协变

协变性（Covariance）：指的是能够使用子类型（子类或者更具体的类型）替换父类型（父类或者更抽象的类型）。

在Java中数组是协变的。如果Cat是Animal的子类型，那么Cat[]也是Animal[]的子类型。

### 逆变

逆变，也称为逆协变，从名字也可以看出来，它与协变的性质是相反的，指的是能够使用父类型替换子类型。

### 泛型的不变性

泛型是不变性的，也就是说`List<Cat>`并不是`List<Animal>`的子类型。

## 泛型的类型擦除

泛型代码内部并不存在有关泛型参数类型的可用信息。Java泛型是通过类型擦除实现的，意味着在使用泛型时，任何具体的类型信息都将被擦除。因此`List<String>`和`List<Integer>`是在运行时是相同的类型，两者的类型都被“擦除”为它们的原始类型`List`

> 为什么泛型这样实现
>

类型擦除的核心初衷是，希望让泛化的调用方程序可以依赖于非泛化的库正常使用即迁移兼容性。

### 上界和下界

这里的上界和下界，本质上指的是，在定义泛型的时候，子类型的边界。即在运行时真正的类型。并且为了最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。

### PECS法则

PECS代表producer-extends,consumer-super。

如果参数化类型表示一个生产者T，就使用`<? extends T>`; 如果表示一个消费者，就使用`<? super T>`。



## 类型擦除的补偿

由于类型擦除的缘故，失去了在泛型代码中执行某些操作的能力。如何需要在运行时知道确切类型的操作都无法运行。

### 创建类型实例

> 传入工厂对象Class
>`` 

```java
@NoArgsConstructor
class Building {
}

@NoArgsConstructor
class House extends Building {
}

public class ClassTypeCapture<T> implements Supplier<T> {
    Class<T> kind;

    public ClassTypeCapture(Class<T> kind) {
        this.kind = kind;
    }

    public boolean f(Object arg) {
        return kind.isInstance(arg);
    }

    @Override
    public T get() {
        try {
            return kind.getConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException |
                 NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        ClassTypeCapture<Building> ctt1 = new ClassTypeCapture<>(Building.class);
        System.out.println(ctt1.f(new Building())); // true
        System.out.println(ctt1.f(new House())); // true
        ClassTypeCapture<House> ctt2 = new ClassTypeCapture<>(House.class);
        System.out.println(ctt2.f(new Building())); // false
        System.out.println(ctt2.f(new House())); // true

        System.out.println(ctt2.get()); // House
    }
}
```

问题在于如果使用`ClassTypeCapture<Integer>`则会失败，因为Integer并没有无参构造器。建议使用显式工厂，并对类型进行限制，使其仅能接收实现了该工厂的类。

> 使用模版方法
> 



## 泛型单例工厂

## 任意类型通配符

## 几个注解

### SafeVarargs

SafeVarargs注解表示我们承诺不会对变量参数列表做出任何修改。如果没有这个注解，编译器则会产生警告。

```java
@SafeVarargs
public static <T> List<T> makeList(T... args) {
    List<T> result = new ArrayList<>();
    for (T item : args) {
        result.add(item);
    }
    return result;
}
```

### SuppressWarnings("unchecked")